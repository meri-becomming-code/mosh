
# Created by Dr. Meri Kasprak.
# Dedicated to the academic community to make the world a slightly better, more accessible place.
# Released freely under the GNU GPLv3 License. USE AT YOUR OWN RISK.

import os
import shutil
import re
from datetime import datetime
import zipfile

# --- Third Party Imports ---
try:
    import mammoth
except ImportError:
    mammoth = None

try:
    import openpyxl
    from openpyxl.utils import get_column_letter
except ImportError:
    openpyxl = None

try:
    from pptx import Presentation
    from pptx.enum.shapes import MSO_SHAPE_TYPE
except ImportError:
    Presentation = None

try:
    import fitz # PyMuPDF
except ImportError:
    fitz = None

try:
    from pdfminer.high_level import extract_text
except ImportError:
    extract_text = None


# --- HTML Templates ---
HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {{ 
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif; 
            font-size: 16px;
            line-height: 1.6; 
            color: #333;
            max-width: 800px; 
            margin: 0 auto; 
            padding: 40px; 
        }}
        h1 {{ 
            font-size: 2.25em; 
            font-weight: 700;
            color: #4b3190; 
            border-bottom: 2px solid #e0e0e0; 
            padding-bottom: 10px; 
            margin-bottom: 30px;
        }}
        h2 {{ color: #2c3e50; margin-top: 40px; font-weight: 600; border-bottom: 1px solid #eee; padding-bottom: 5px; }}
        h3 {{ color: #444; margin-top: 30px; font-weight: 600; }}
        a {{ color: #0056b3; text-decoration: none; }}
        a:hover {{ text-decoration: underline; }}
        table {{ border-collapse: collapse; width: 100%; margin: 25px 0; font-size: 0.95em; }}
        th, td {{ border: 1px solid #ddd; padding: 12px 15px; text-align: left; }}
        th {{ background-color: #f8f9fa; font-weight: 600; color: #495057; }}
        tr:nth-child(even) {{ background-color: #f8f9fa; }}
        img {{ max-width: 100%; height: auto; border-radius: 4px; border: 1px solid #eee; }}
        .grading-note {{ background-color: #e8f5e9; padding: 10px; border-left: 4px solid #4caf50; font-style: italic; }}
        .note {{ font-size: 0.9em; color: #666; background: #fff3cd; padding: 15px; border-radius: 4px; border: 1px solid #ffeeba; }}
        code {{ background-color: #f1f3f5; padding: 2px 5px; border-radius: 4px; font-family: Consolas, monospace; color: #d63384; }}
    </style>
</head>
<body>
    <h1>{title}</h1>
    <p class="note">✅ Remediated content from {source_file}</p>
    {content}
</body>
</html>
"""

def _save_html(content, title, source_file, output_path):
    """Wraps content in template and saves file."""
    html = HTML_TEMPLATE.format(
        title=title,
        source_file=os.path.basename(source_file),
        date=datetime.now().strftime("%Y-%m-%d"),
        content=content
    )
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(html)
    return output_path

# --- Converters ---

def convert_docx_to_html(docx_path):
    """Converts DOCX to HTML using Mammoth (with style mapping)."""
    if not mammoth:
        return None, "Mammoth library not installed."

    try:
        # Custom Style Map for Canvas alignment
        style_map = """
        p[style-name='Title'] => h1:fresh
        p[style-name='Heading 1'] => h2:fresh
        p[style-name='Heading 2'] => h3:fresh
        p[style-name='Heading 3'] => h4:fresh
        p[style-name='Heading 4'] => h5:fresh
        p[style-name='Complete/Incomplete'] => p.grading-note:fresh
        r[style-name='Strong'] => strong
        b => strong
        i => em
        """
        
        with open(docx_path, "rb") as docx_file:
            result = mammoth.convert_to_html(docx_file, style_map=style_map)
            html_content = result.value
            messages = result.messages # Warnings

        # Post-Processing: Basic Cleanup
        # Remove empty paragraphs often generated by extra Returns in Word
        html_content = html_content.replace("<p></p>", "").replace("<p>&nbsp;</p>", "")
        
        # Ensure tables have some basic class for our CSS
        html_content = html_content.replace("<table>", '<table class="content-table">')

        filename = os.path.splitext(os.path.basename(docx_path))[0]
        output_path = os.path.join(os.path.dirname(docx_path), f"{filename}.html")
        
        # Wrap in template
        _save_html(html_content, filename, docx_path, output_path)
        
        return output_path, None
    except Exception as e:
        return None, str(e)


def convert_excel_to_html(xlsx_path):
    """Converts Excel to HTML Tables using OpenPyXL."""
    if not openpyxl:
        return None, "OpenPyXL library not installed."

    try:
        wb = openpyxl.load_workbook(xlsx_path, data_only=True)
        html_parts = []
        
        for sheet_name in wb.sheetnames:
            ws = wb[sheet_name]
            html_parts.append(f"<h2>Sheet: {sheet_name}</h2>")
            html_parts.append("<table>")
            
            rows = list(ws.rows)
            if rows:
                # Header
                html_parts.append("<thead><tr>")
                for cell in rows[0]:
                    val = cell.value if cell.value is not None else ""
                    html_parts.append(f"<th>{val}</th>")
                html_parts.append("</tr></thead>")
                
                # Body
                html_parts.append("<tbody>")
                for row in rows[1:]:
                    html_parts.append("<tr>")
                    for cell in row:
                        val = cell.value if cell.value is not None else ""
                        html_parts.append(f"<td>{val}</td>")
                    html_parts.append("</tr>")
                html_parts.append("</tbody>")
            
            html_parts.append("</table>")

        full_content = "\n".join(html_parts)
        
        filename = os.path.splitext(os.path.basename(xlsx_path))[0]
        output_path = os.path.join(os.path.dirname(xlsx_path), f"{filename}.html")
        
        _save_html(full_content, filename, xlsx_path, output_path)
        return output_path, None
        
    except Exception as e:
        return None, str(e)


def convert_ppt_to_html(ppt_path):
    """Converts PPTX to HTML Lecture Notes + Extracts Images."""
    if not Presentation:
        return None, "python-pptx library not installed."

    try:
        prs = Presentation(ppt_path)
        filename = os.path.splitext(os.path.basename(ppt_path))[0]
        output_dir = os.path.dirname(ppt_path)
        
        # Media Folder
        media_folder_name = f"{filename}_media"
        media_path = os.path.join(output_dir, media_folder_name)
        if not os.path.exists(media_path):
            os.makedirs(media_path)

        html_parts = []
        
        for i, slide in enumerate(prs.slides):
            slide_num = i + 1
            html_parts.append(f'<div class="slide-container" id="slide-{slide_num}">')
            html_parts.append(f'<p class="note">Slide {slide_num}</p>')
            
            # Title
            if slide.shapes.title:
                title_text = slide.shapes.title.text_frame.text
                html_parts.append(f'<h2 class="slide-title">{title_text}</h2>')
            
            # Content (Text & Images)
            for shape in slide.shapes:
                # Text
                if shape.has_text_frame:
                    if shape == slide.shapes.title: continue # Skip title (already added)
                    
                    text_content = []
                    for paragraph in shape.text_frame.paragraphs:
                        txt = paragraph.text.strip()
                        if txt:
                            text_content.append(f"<li>{txt}</li>")
                    
                    if text_content:
                        html_parts.append("<ul>" + "".join(text_content) + "</ul>")

                # Images
                if shape.shape_type == MSO_SHAPE_TYPE.PICTURE:
                    try:
                        image = shape.image
                        image_bytes = image.blob
                        # Guess extension
                        ext = image.ext
                        image_filename = f"slide{slide_num}_image_{shape.shape_id}.{ext}"
                        image_full_path = os.path.join(media_path, image_filename)
                        
                        with open(image_full_path, 'wb') as img_f:
                            img_f.write(image_bytes)
                            
                        # Embed in HTML with FIX_ME
                        rel_path = f"{media_folder_name}/{image_filename}"
                        html_parts.append(f'<img src="{rel_path}" alt="[FIX_ME] Image from Slide {slide_num}" class="slide-image">')
                    except Exception as img_err:
                        print(f"Skipped image on slide {slide_num}: {img_err}")

            html_parts.append('</div>')

        full_content = "\n".join(html_parts)
        output_path = os.path.join(output_dir, f"{filename}.html")
        
        _save_html(full_content, filename, ppt_path, output_path)
        return output_path, None

    except Exception as e:
        return None, str(e)


def convert_pdf_to_html(pdf_path):
    """Converts PDF to HTML using PyMuPDF (Images + Text)."""
    if not fitz:
        if not extract_text:
             return None, "Neither PyMuPDF (fitz) nor pdfminer.six are installed."
        else:
             # Fallback to old method if fitz is missing (though we just installed it)
             return _convert_pdf_fallback(pdf_path)

    try:
        doc = fitz.open(pdf_path)
        filename = os.path.splitext(os.path.basename(pdf_path))[0]
        output_dir = os.path.dirname(pdf_path)
        
        # Media Folder
        media_folder_name = f"{filename}_media"
        media_path = os.path.join(output_dir, media_folder_name)
        if not os.path.exists(media_path):
            os.makedirs(media_path)
            
        html_parts = []
        html_parts.append('<div class="pdf-content">')
        
        for i, page in enumerate(doc):
            page_num = i + 1
            html_parts.append(f'<div class="page-container" id="page-{page_num}" style="margin-bottom: 30px; border-bottom: 1px solid #ccc; padding-bottom: 20px;">')
            html_parts.append(f'<p class="note">Page {page_num}</p>')
            
            # 1. Extract Images
            image_list = page.get_images()
            for img_index, img in enumerate(image_list):
                xref = img[0]
                try:
                    base_image = doc.extract_image(xref)
                    image_bytes = base_image["image"]
                    ext = base_image["ext"]
                    
                    image_filename = f"page{page_num}_img{img_index + 1}.{ext}"
                    image_full_path = os.path.join(media_path, image_filename)
                    
                    with open(image_full_path, "wb") as f:
                        f.write(image_bytes)
                        
                    rel_path = f"{media_folder_name}/{image_filename}"
                    html_parts.append(f'<img src="{rel_path}" alt="[FIX_ME] Image from Page {page_num}" class="content-image" style="max-width: 100%; height: auto; display: block; margin: 10px 0;">')
                except:
                    pass

            # 2. Extract Text (Blocks to preserve some structure)
            blocks = page.get_text("blocks")
            for b in blocks:
                # b = (x0, y0, x1, y1, text, block_no, block_type)
                text = b[4].strip()
                if not text: continue
                
                # Heuristic for headers: Short lines, no ending period?
                # PyMuPDF doesn't give font info in "blocks" mode easily without "dict"
                # Keep it simple for now.
                if len(text) < 80 and not text.endswith('.') and not text.endswith(','):
                     html_parts.append(f"<h3>{text}</h3>")
                else:
                     # Escape HTML chars? Basic replace
                     safe_text = text.replace("<", "&lt;").replace(">", "&gt;").replace("\n", "<br>")
                     html_parts.append(f"<p>{safe_text}</p>")

            html_parts.append('</div>')

        html_parts.append('</div>')
        
        full_content = "\n".join(html_parts)
        output_path = os.path.join(output_dir, f"{filename}.html")
        
        _save_html(full_content, filename, pdf_path, output_path)
        return output_path, None

    except Exception as e:
        return None, f"PyMuPDF Error: {str(e)}"

def _convert_pdf_fallback(pdf_path):
    """Legacy text-only converter using pdfminer."""
    try:
        text = extract_text(pdf_path)
        paragraphs = text.split('\n\n')
        html_parts = []
        html_parts.append('<div class="pdf-content">')
        html_parts.append('<p class="note">⚠️ Text-Only Extraction (Images Missing).</p>')
        
        for p in paragraphs:
             clean_p = p.strip()
             if clean_p:
                  html_parts.append(f"<p>{clean_p}</p>")
        
        html_parts.append('</div>')
        full_content = "\n".join(html_parts)
        filename = os.path.splitext(os.path.basename(pdf_path))[0]
        output_path = os.path.join(os.path.dirname(pdf_path), f"{filename}.html")
        _save_html(full_content, filename, pdf_path, output_path)
        return output_path, None

    except Exception as e:
        return None, str(e)


def update_links_in_directory(directory, old_filename, new_filename):

    """
    Scans all HTML files in directory and replaces links.
    e.g. href="syllabus.docx" -> href="syllabus.html"
    """
    count = 0
    old_base = os.path.basename(old_filename)
    new_base = os.path.basename(new_filename)
    
    # URL encode spaces for href matching just in case
    old_base_enc = old_base.replace(' ', '%20')
    new_base_enc = new_base.replace(' ', '%20')

    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith('.html'):
                filepath = os.path.join(root, file)
                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # Naive replace, but safe enough for filenames? 
                    # Consider strictly within href="..." but simple replace often works for unique filenames.
                    if old_base in content or old_base_enc in content:
                        new_content = content.replace(old_base, new_base)
                        new_content = new_content.replace(old_base_enc, new_base_enc)
                        
                        if new_content != content:
                            with open(filepath, 'w', encoding='utf-8') as f:
                                f.write(new_content)
                            count += 1
                except:
                    pass
    return count

def unzip_course_package(zip_path, extract_to):
    """
    Extracts a Canvas Export (.imscc) or Zip file to the target directory.
    Renames .imscc to .zip internally if needed.
    """
    try:
        if not os.path.exists(extract_to):
            os.makedirs(extract_to)
            
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(extract_to)
            
        return True, f"Successfully extracted to: {extract_to}"
    except Exception as e:
        return False, str(e)

def create_course_package(source_dir, output_path):
    """
    Zips the directory back into a .imscc file.
    """
    try:
        with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(source_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    # Archive name should be relative to source_dir
                    arcname = os.path.relpath(file_path, source_dir)
                    zipf.write(file_path, arcname)
        return True, f"Created: {output_path}"
    except Exception as e:
        return False, str(e)
